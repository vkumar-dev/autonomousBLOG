#!/usr/bin/env node

/**
 * Convert HTML articles to Markdown with frontmatter
 * Extracts title, date, and content from HTML files and creates markdown versions
 */

const fs = require('fs');
const path = require('path');

const ARTICLES_DIR = path.join(__dirname, '..', 'articles');

function slugify(text) {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '');
}

function extractMetadataFromHTML(content) {
  const title = content.match(/<title>(.*?)<\/title>/)?.[1] || 'Untitled';
  const dateMatch = content.match(/meta name="date" content="(.*?)"/);
  const tagsMatch = content.match(/meta name="tags" content="(.*?)"/);
  
  const date = dateMatch?.[1] || new Date().toISOString();
  const tags = tagsMatch?.[1]?.split(', ') || [];
  
  return { title, date, tags };
}

function extractContentFromHTML(content) {
  // Extract the main article content
  const mainMatch = content.match(/<main[^>]*>([\s\S]*?)<\/main>/);
  let bodyContent = mainMatch?.[1] || '';
  
  if (!bodyContent) {
    // Fallback: extract from article tag
    const articleMatch = content.match(/<article[^>]*>([\s\S]*?)<\/article>/);
    bodyContent = articleMatch?.[1] || '';
  }
  
  // Remove HTML tags but keep structure
  bodyContent = bodyContent
    .replace(/<h1[^>]*>(.*?)<\/h1>/g, '# $1')
    .replace(/<h2[^>]*>(.*?)<\/h2>/g, '## $1')
    .replace(/<h3[^>]*>(.*?)<\/h3>/g, '### $1')
    .replace(/<p[^>]*>(.*?)<\/p>/g, '$1\n')
    .replace(/<li[^>]*>(.*?)<\/li>/g, '- $1')
    .replace(/<ul[^>]*>|<\/ul>/g, '')
    .replace(/<ol[^>]*>|<\/ol>/g, '')
    .replace(/<br\s*\/?>/g, '\n')
    .replace(/<[^>]*>/g, '')
    .replace(/&nbsp;/g, ' ')
    .replace(/&quot;/g, '"')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .trim();
  
  return bodyContent;
}

function convertHTMLFile(filePath) {
  const fileName = path.basename(filePath);
  const content = fs.readFileSync(filePath, 'utf8');
  
  const { title, date, tags } = extractMetadataFromHTML(content);
  const bodyContent = extractContentFromHTML(content);
  
  // Generate slug and determine output path
  const slug = slugify(title);
  const dateObj = new Date(date);
  const year = dateObj.getFullYear();
  const month = String(dateObj.getMonth() + 1).padStart(2, '0');
  
  const outputDir = path.join(ARTICLES_DIR, String(year), month);
  const outputFile = path.join(outputDir, `${slug}.md`);
  
  // Calculate reading time
  const wordCount = bodyContent.split(/\s+/).length;
  const readingTime = Math.ceil(wordCount / 200);
  
  // Create markdown with frontmatter
  const markdown = `---
title: "${title.replace(/"/g, '\\"')}"
date: "${date}"
theme: "default"
topic: "${title.replace(/"/g, '\\"')}"
contentType: "article"
excerpt: "${bodyContent.substring(0, 150).replace(/"/g, '\\"')}..."
readingTime: ${readingTime}
wordCount: ${wordCount}
keywords: ${JSON.stringify(tags)}
---

${bodyContent}

---

*Generated by autonomousBLOG*
`;
  
  // Create directory if it doesn't exist
  fs.mkdirSync(outputDir, { recursive: true });
  
  // Write markdown file
  fs.writeFileSync(outputFile, markdown);
  
  console.log(`✅ Converted: ${fileName} -> ${path.relative(ARTICLES_DIR, outputFile)}`);
  
  return { success: true, output: outputFile };
}

function main() {
  if (!fs.existsSync(ARTICLES_DIR)) {
    console.log('Articles directory does not exist');
    return;
  }
  
  const files = fs.readdirSync(ARTICLES_DIR);
  let converted = 0;
  
  for (const file of files) {
    const filePath = path.join(ARTICLES_DIR, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isFile() && file.endsWith('.html')) {
      try {
        convertHTMLFile(filePath);
        converted++;
      } catch (error) {
        console.error(`❌ Error converting ${file}:`, error.message);
      }
    }
  }
  
  console.log(`\n✅ Conversion complete: ${converted} HTML files processed`);
}

if (require.main === module) {
  main();
}

module.exports = { convertHTMLFile };
